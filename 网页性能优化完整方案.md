# âš¡ Jinbao Protocol ç½‘é¡µæ€§èƒ½ä¼˜åŒ–å®Œæ•´æ–¹æ¡ˆ

## ğŸ“Š å½“å‰æ€§èƒ½åˆ†æ

åŸºäºæ‚¨çš„æŠ€æœ¯æ ˆåˆ†æï¼š
- **å‰ç«¯**: React 19 + Vite 4.5.14 + TypeScript
- **éƒ¨ç½²**: Cloudflare Pages + Functions
- **Web3**: Wagmi 2.19.5 + RainbowKit 2.2.10 + Ethers.js 6.8.0
- **UI**: Tailwind CSS + Lucide React + Recharts

---

## ğŸš€ å‰ç«¯æ€§èƒ½ä¼˜åŒ–

### ğŸ“¦ 1. æ„å»ºä¼˜åŒ– (Viteé…ç½®å¢å¼º)

#### ğŸ”§ ä¼˜åŒ–åçš„ vite.config.ts
```typescript
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';
import { visualizer } from 'rollup-plugin-visualizer';
import { compression } from 'vite-plugin-compression';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    const isProduction = mode === 'production';
    
    return {
        server: {
            port: 5173,
            host: '0.0.0.0',
            headers: {
                'Cross-Origin-Opener-Policy': 'same-origin-allow-popups',
            },
        },
        plugins: [
            react({
                // å¯ç”¨React Fast Refresh
                fastRefresh: !isProduction,
                // ç”Ÿäº§ç¯å¢ƒç§»é™¤å¼€å‘å·¥å…·
                babel: isProduction ? {
                    plugins: [
                        ['babel-plugin-react-remove-properties', { properties: ['data-testid'] }]
                    ]
                } : undefined
            }),
            // Gzipå‹ç¼©
            compression({
                algorithm: 'gzip',
                ext: '.gz',
                threshold: 1024, // åªå‹ç¼©å¤§äº1KBçš„æ–‡ä»¶
            }),
            // Brotliå‹ç¼© (æ›´å¥½çš„å‹ç¼©ç‡)
            compression({
                algorithm: 'brotliCompress',
                ext: '.br',
                threshold: 1024,
            }),
            // æ„å»ºåˆ†æå·¥å…·
            isProduction && visualizer({
                filename: 'dist/stats.html',
                open: false,
                gzipSize: true,
                brotliSize: true,
            }),
        ].filter(Boolean),
        
        define: {
            'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
            'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY),
            // ç§»é™¤ç”Ÿäº§ç¯å¢ƒçš„console
            ...(isProduction && {
                'console.log': '(() => {})',
                'console.warn': '(() => {})',
                'console.error': '(() => {})',
            })
        },
        
        // ä¾èµ–é¢„æ„å»ºä¼˜åŒ–
        optimizeDeps: {
            include: [
                'react',
                'react-dom',
                'ethers',
                '@rainbow-me/rainbowkit',
                'wagmi',
                'viem',
                'react-hot-toast',
                'recharts',
                'lucide-react'
            ],
            esbuildOptions: {
                define: {
                    global: 'globalThis'
                },
                target: 'es2020'
            }
        },
        
        // æ„å»ºä¼˜åŒ–
        build: {
            target: 'es2020',
            minify: 'terser',
            terserOptions: {
                compress: {
                    drop_console: isProduction,
                    drop_debugger: isProduction,
                    pure_funcs: isProduction ? ['console.log', 'console.warn'] : []
                }
            },
            rollupOptions: {
                output: {
                    // ä»£ç åˆ†å‰²ç­–ç•¥
                    manualChunks: {
                        // æ ¸å¿ƒReactåº“
                        'react-vendor': ['react', 'react-dom'],
                        // Web3ç›¸å…³åº“
                        'web3-vendor': ['ethers', '@rainbow-me/rainbowkit', 'wagmi', 'viem'],
                        // UIç»„ä»¶åº“
                        'ui-vendor': ['lucide-react', 'recharts', 'react-hot-toast'],
                        // å·¥å…·åº“
                        'utils-vendor': ['@tanstack/react-query']
                    },
                    // æ–‡ä»¶å‘½åä¼˜åŒ–
                    chunkFileNames: 'assets/js/[name]-[hash].js',
                    entryFileNames: 'assets/js/[name]-[hash].js',
                    assetFileNames: (assetInfo) => {
                        const info = assetInfo.name.split('.');
                        const ext = info[info.length - 1];
                        if (/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/i.test(assetInfo.name)) {
                            return `assets/media/[name]-[hash].${ext}`;
                        }
                        if (/\.(png|jpe?g|gif|svg|webp|avif)(\?.*)?$/i.test(assetInfo.name)) {
                            return `assets/img/[name]-[hash].${ext}`;
                        }
                        if (/\.(woff2?|eot|ttf|otf)(\?.*)?$/i.test(assetInfo.name)) {
                            return `assets/fonts/[name]-[hash].${ext}`;
                        }
                        return `assets/[ext]/[name]-[hash].${ext}`;
                    }
                }
            },
            // å¯ç”¨æºç æ˜ å°„ (ä»…å¼€å‘ç¯å¢ƒ)
            sourcemap: !isProduction,
            // æ„å»ºæŠ¥å‘Š
            reportCompressedSize: true,
            // å—å¤§å°è­¦å‘Šé™åˆ¶
            chunkSizeWarningLimit: 1000
        },
        
        resolve: {
            alias: {
                '@': path.resolve(__dirname, '.'),
                '@components': path.resolve(__dirname, 'components'),
                '@src': path.resolve(__dirname, 'src'),
                '@utils': path.resolve(__dirname, 'utils'),
                '@hooks': path.resolve(__dirname, 'hooks'),
            }
        },
        
        // CSSä¼˜åŒ–
        css: {
            devSourcemap: !isProduction,
            postcss: {
                plugins: isProduction ? [
                    require('autoprefixer'),
                    require('cssnano')({
                        preset: ['default', {
                            discardComments: { removeAll: true },
                            normalizeWhitespace: true
                        }]
                    })
                ] : []
            }
        }
    };
});
```

#### ğŸ“‹ éœ€è¦å®‰è£…çš„ä¾èµ–
```bash
npm install --save-dev rollup-plugin-visualizer vite-plugin-compression terser autoprefixer cssnano babel-plugin-react-remove-properties
```

### ğŸ¨ 2. ç»„ä»¶çº§ä¼˜åŒ–

#### âš¡ Reactæ€§èƒ½ä¼˜åŒ–ç»„ä»¶
```typescript
// src/components/optimized/LazyImage.tsx
import React, { useState, useRef, useEffect } from 'react';

interface LazyImageProps {
  src: string;
  alt: string;
  className?: string;
  placeholder?: string;
}

export const LazyImage: React.FC<LazyImageProps> = ({ 
  src, 
  alt, 
  className = '', 
  placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMSIgaGVpZ2h0PSIxIiB2aWV3Qm94PSIwIDAgMSAxIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNGM0Y0RjYiLz48L3N2Zz4='
}) => {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [isLoaded, setIsLoaded] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setImageSrc(src);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, [src]);

  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      className={`transition-opacity duration-300 ${isLoaded ? 'opacity-100' : 'opacity-70'} ${className}`}
      onLoad={() => setIsLoaded(true)}
      loading="lazy"
    />
  );
};
```

#### ğŸ”„ è™šæ‹Ÿæ»šåŠ¨ç»„ä»¶ (ç”¨äºå¤§æ•°æ®åˆ—è¡¨)
```typescript
// src/components/optimized/VirtualList.tsx
import React, { useState, useEffect, useRef, useMemo } from 'react';

interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
  overscan?: number;
}

export function VirtualList<T>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 5
}: VirtualListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  const scrollElementRef = useRef<HTMLDivElement>(null);

  const { visibleItems, offsetY, totalHeight } = useMemo(() => {
    const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
    const endIndex = Math.min(
      items.length - 1,
      Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan
    );

    const visibleItems = items.slice(startIndex, endIndex + 1).map((item, index) => ({
      item,
      index: startIndex + index
    }));

    return {
      visibleItems,
      offsetY: startIndex * itemHeight,
      totalHeight: items.length * itemHeight
    };
  }, [items, itemHeight, scrollTop, containerHeight, overscan]);

  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  };

  return (
    <div
      ref={scrollElementRef}
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map(({ item, index }) => (
            <div key={index} style={{ height: itemHeight }}>
              {renderItem(item, index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

#### ğŸ¯ æ™ºèƒ½ç¼“å­˜Hook
```typescript
// src/hooks/useSmartCache.ts
import { useState, useEffect, useRef } from 'react';

interface CacheOptions {
  ttl?: number; // ç¼“å­˜æ—¶é—´ (æ¯«ç§’)
  maxSize?: number; // æœ€å¤§ç¼“å­˜æ¡ç›®æ•°
}

export function useSmartCache<T>(options: CacheOptions = {}) {
  const { ttl = 5 * 60 * 1000, maxSize = 100 } = options; // é»˜è®¤5åˆ†é’ŸTTL
  const cacheRef = useRef(new Map<string, { data: T; timestamp: number }>());
  const [, forceUpdate] = useState({});

  const set = (key: string, data: T) => {
    const cache = cacheRef.current;
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    const now = Date.now();
    for (const [k, v] of cache.entries()) {
      if (now - v.timestamp > ttl) {
        cache.delete(k);
      }
    }
    
    // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€æ—§çš„æ¡ç›®
    if (cache.size >= maxSize) {
      const oldestKey = cache.keys().next().value;
      cache.delete(oldestKey);
    }
    
    cache.set(key, { data, timestamp: now });
    forceUpdate({});
  };

  const get = (key: string): T | null => {
    const cached = cacheRef.current.get(key);
    if (!cached) return null;
    
    const now = Date.now();
    if (now - cached.timestamp > ttl) {
      cacheRef.current.delete(key);
      return null;
    }
    
    return cached.data;
  };

  const clear = () => {
    cacheRef.current.clear();
    forceUpdate({});
  };

  const has = (key: string): boolean => {
    const cached = cacheRef.current.get(key);
    if (!cached) return false;
    
    const now = Date.now();
    if (now - cached.timestamp > ttl) {
      cacheRef.current.delete(key);
      return false;
    }
    
    return true;
  };

  return { set, get, clear, has, size: cacheRef.current.size };
}
```

### ğŸŒ 3. Web3æ€§èƒ½ä¼˜åŒ–

#### âš¡ ä¼˜åŒ–çš„Web3Provider
```typescript
// src/providers/OptimizedWeb3Provider.tsx
import React, { createContext, useContext, useMemo } from 'react';
import { WagmiConfig, createConfig, configureChains } from 'wagmi';
import { publicProvider } from 'wagmi/providers/public';
import { jsonRpcProvider } from 'wagmi/providers/jsonRpc';
import { RainbowKitProvider, getDefaultWallets } from '@rainbow-me/rainbowkit';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// å¤šRPCæä¾›å•†é…ç½®
const mcChain = {
  id: 88813,
  name: 'MC Chain',
  network: 'mc',
  nativeCurrency: { name: 'MC', symbol: 'MC', decimals: 18 },
  rpcUrls: {
    default: { http: ['https://chain.mcerscan.com/'] },
    public: { http: ['https://chain.mcerscan.com/'] },
  },
  blockExplorers: {
    default: { name: 'MCerscan', url: 'https://mcerscan.com/' },
  },
};

// é…ç½®å¤šä¸ªRPCæä¾›å•†ä»¥æé«˜å¯é æ€§
const { chains, publicClient, webSocketPublicClient } = configureChains(
  [mcChain],
  [
    jsonRpcProvider({
      rpc: () => ({
        http: 'https://chain.mcerscan.com/',
        webSocket: 'wss://chain.mcerscan.com/ws', // å¦‚æœæ”¯æŒWebSocket
      }),
    }),
    // å¤‡ç”¨RPC (å¦‚æœæœ‰)
    jsonRpcProvider({
      rpc: () => ({
        http: 'https://rpc-backup.mcchain.io/', // å¤‡ç”¨RPC
      }),
    }),
    publicProvider(),
  ],
  {
    // å¯ç”¨æ‰¹é‡è¯·æ±‚
    batch: {
      multicall: {
        batchSize: 1024 * 200, // 200KBæ‰¹é‡å¤§å°
        wait: 16, // 16msç­‰å¾…æ—¶é—´
      },
    },
    // å¯ç”¨ç¼“å­˜
    pollingInterval: 4000, // 4ç§’è½®è¯¢é—´éš”
  }
);

const { connectors } = getDefaultWallets({
  appName: 'Jinbao Protocol',
  projectId: process.env.WALLETCONNECT_PROJECT_ID || 'your-project-id',
  chains,
});

const wagmiConfig = createConfig({
  autoConnect: true,
  connectors,
  publicClient,
  webSocketPublicClient,
});

// ä¼˜åŒ–çš„QueryClienté…ç½®
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ç¼“å­˜æ—¶é—´5åˆ†é’Ÿ
      staleTime: 5 * 60 * 1000,
      // æ•°æ®ä¿æŒæ—¶é—´10åˆ†é’Ÿ
      cacheTime: 10 * 60 * 1000,
      // å¤±è´¥é‡è¯•é…ç½®
      retry: (failureCount, error) => {
        // ç½‘ç»œé”™è¯¯é‡è¯•3æ¬¡ï¼Œå…¶ä»–é”™è¯¯é‡è¯•1æ¬¡
        if (error?.message?.includes('network')) {
          return failureCount < 3;
        }
        return failureCount < 1;
      },
      // é‡è¯•å»¶è¿Ÿ
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
});

export const OptimizedWeb3Provider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <QueryClientProvider client={queryClient}>
      <WagmiConfig config={wagmiConfig}>
        <RainbowKitProvider
          chains={chains}
          theme={{
            lightMode: {
              // è‡ªå®šä¹‰ä¸»é¢˜ä»¥å‡å°‘CSSåŠ è½½
              colors: {
                accentColor: '#1E40AF',
                accentColorForeground: 'white',
              },
            },
          }}
          showRecentTransactions={true}
          coolMode={false} // ç¦ç”¨åŠ¨ç”»ä»¥æå‡æ€§èƒ½
        >
          {children}
        </RainbowKitProvider>
      </WagmiConfig>
    </QueryClientProvider>
  );
};
```

#### ğŸ”„ æ™ºèƒ½åˆçº¦è°ƒç”¨ä¼˜åŒ–
```typescript
// src/hooks/useOptimizedContract.ts
import { useContract, useProvider } from 'wagmi';
import { useMemo } from 'react';
import { useSmartCache } from './useSmartCache';

export function useOptimizedContract(address: string, abi: any[]) {
  const provider = useProvider();
  const cache = useSmartCache({ ttl: 30000 }); // 30ç§’ç¼“å­˜

  const contract = useContract({
    address,
    abi,
    signerOrProvider: provider,
  });

  const cachedCall = useMemo(() => {
    return async (method: string, ...args: any[]) => {
      const cacheKey = `${address}-${method}-${JSON.stringify(args)}`;
      
      // æ£€æŸ¥ç¼“å­˜
      const cached = cache.get(cacheKey);
      if (cached) return cached;
      
      try {
        const result = await contract[method](...args);
        cache.set(cacheKey, result);
        return result;
      } catch (error) {
        console.error(`Contract call failed: ${method}`, error);
        throw error;
      }
    };
  }, [contract, cache, address]);

  return { contract, cachedCall };
}
```

---

## ğŸŒ Cloudflareä¼˜åŒ–é…ç½®

### âš¡ 1. å¢å¼ºçš„wrangler.tomlé…ç½®
```toml
# ä¼˜åŒ–åçš„ wrangler.toml
name = "jbc-ac"
compatibility_date = "2024-01-01"
pages_build_output_dir = "dist"

# å…¨å±€ä¼˜åŒ–è®¾ç½®
[build]
command = "npm run build"
cwd = "."
watch_dir = "src"

# ç”Ÿäº§ç¯å¢ƒé…ç½®
[env.production]
name = "jbc-ac-production"
compatibility_date = "2024-01-01"
compatibility_flags = ["nodejs_compat"]

[env.production.vars]
ENVIRONMENT = "production"
NODE_ENV = "production"
DAILY_BURN_AMOUNT = "500"
MAX_BURN_AMOUNT = "5000"
BURN_PERCENTAGE = "0.1"
MIN_BALANCE_THRESHOLD = "1000"
# æ€§èƒ½ä¼˜åŒ–å˜é‡
CACHE_TTL = "3600"
MAX_CONCURRENT_REQUESTS = "100"
RATE_LIMIT_PER_MINUTE = "1000"

# é¢„è§ˆç¯å¢ƒé…ç½®
[env.preview]
name = "jbc-ac-preview"
compatibility_date = "2024-01-01"
compatibility_flags = ["nodejs_compat"]

[env.preview.vars]
ENVIRONMENT = "preview"
NODE_ENV = "development"
DAILY_BURN_AMOUNT = "10"
MAX_BURN_AMOUNT = "100"
BURN_PERCENTAGE = "0.01"
MIN_BALANCE_THRESHOLD = "50"
CACHE_TTL = "300"
MAX_CONCURRENT_REQUESTS = "50"
RATE_LIMIT_PER_MINUTE = "500"

# è·¯ç”±è§„åˆ™ä¼˜åŒ–
[[env.production.routes]]
pattern = "/api/*"
custom_domain = true

[[env.production.routes]]
pattern = "/assets/*"
custom_domain = true

# ç¼“å­˜è§„åˆ™
[env.production.cache]
browser_ttl = 31536000  # 1å¹´
edge_ttl = 86400       # 1å¤©
```

### ğŸš€ 2. Cloudflare Functionsä¼˜åŒ–

#### âš¡ ä¼˜åŒ–çš„APIå‡½æ•°
```typescript
// functions/api/optimized-data.ts
export interface Env {
  CACHE_TTL: string;
  MAX_CONCURRENT_REQUESTS: string;
  RATE_LIMIT_PER_MINUTE: string;
}

// å†…å­˜ç¼“å­˜
const cache = new Map<string, { data: any; timestamp: number }>();

// é€Ÿç‡é™åˆ¶
const rateLimiter = new Map<string, { count: number; resetTime: number }>();

export const onRequest: PagesFunction<Env> = async (context) => {
  const { request, env } = context;
  const url = new URL(request.url);
  const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';
  
  // é€Ÿç‡é™åˆ¶æ£€æŸ¥
  const rateLimit = parseInt(env.RATE_LIMIT_PER_MINUTE || '1000');
  const now = Date.now();
  const resetTime = Math.floor(now / 60000) * 60000 + 60000; // ä¸‹ä¸€åˆ†é’Ÿ
  
  const userRate = rateLimiter.get(clientIP);
  if (userRate) {
    if (now < userRate.resetTime) {
      if (userRate.count >= rateLimit) {
        return new Response('Rate limit exceeded', { status: 429 });
      }
      userRate.count++;
    } else {
      rateLimiter.set(clientIP, { count: 1, resetTime });
    }
  } else {
    rateLimiter.set(clientIP, { count: 1, resetTime });
  }

  // ç¼“å­˜æ£€æŸ¥
  const cacheKey = `${url.pathname}${url.search}`;
  const cacheTTL = parseInt(env.CACHE_TTL || '300') * 1000;
  const cached = cache.get(cacheKey);
  
  if (cached && (now - cached.timestamp) < cacheTTL) {
    return new Response(JSON.stringify(cached.data), {
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': `public, max-age=${Math.floor(cacheTTL / 1000)}`,
        'X-Cache': 'HIT'
      }
    });
  }

  try {
    // å®é™…æ•°æ®è·å–é€»è¾‘
    const data = await fetchData(url.pathname);
    
    // æ›´æ–°ç¼“å­˜
    cache.set(cacheKey, { data, timestamp: now });
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    for (const [key, value] of cache.entries()) {
      if ((now - value.timestamp) > cacheTTL) {
        cache.delete(key);
      }
    }

    return new Response(JSON.stringify(data), {
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': `public, max-age=${Math.floor(cacheTTL / 1000)}`,
        'X-Cache': 'MISS'
      }
    });
  } catch (error) {
    return new Response('Internal Server Error', { status: 500 });
  }
};

async function fetchData(path: string) {
  // æ¨¡æ‹Ÿæ•°æ®è·å–
  switch (path) {
    case '/api/user-stats':
      return { stats: 'user data' };
    case '/api/pool-info':
      return { pool: 'pool data' };
    default:
      throw new Error('Not found');
  }
}
```

### ğŸ“Š 3. é™æ€èµ„æºä¼˜åŒ–

#### ğŸ–¼ï¸ å›¾ç‰‡ä¼˜åŒ–é…ç½®
```typescript
// functions/_middleware.ts
export const onRequest: PagesFunction = async (context) => {
  const { request, next } = context;
  const url = new URL(request.url);
  
  // å›¾ç‰‡ä¼˜åŒ–
  if (url.pathname.match(/\.(jpg|jpeg|png|webp|avif)$/i)) {
    const response = await next();
    
    // æ·»åŠ å›¾ç‰‡ä¼˜åŒ–å¤´
    const newResponse = new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: {
        ...response.headers,
        'Cache-Control': 'public, max-age=31536000, immutable',
        'Vary': 'Accept',
      }
    });
    
    return newResponse;
  }
  
  // CSS/JSæ–‡ä»¶ä¼˜åŒ–
  if (url.pathname.match(/\.(css|js)$/i)) {
    const response = await next();
    
    return new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: {
        ...response.headers,
        'Cache-Control': 'public, max-age=31536000, immutable',
        'Content-Encoding': 'br', // å¯ç”¨Brotliå‹ç¼©
      }
    });
  }
  
  return next();
};
```

---

## ğŸ“± ç§»åŠ¨ç«¯ä¼˜åŒ–

### ğŸ¯ 1. å“åº”å¼æ€§èƒ½ä¼˜åŒ–
```css
/* src/styles/performance.css */

/* å…³é”®CSSå†…è” */
.critical-above-fold {
  /* é¦–å±å…³é”®æ ·å¼ */
  display: block;
  visibility: visible;
}

/* å»¶è¿ŸåŠ è½½éå…³é”®CSS */
.non-critical {
  /* ä½¿ç”¨CSS containmentæå‡æ€§èƒ½ */
  contain: layout style paint;
}

/* ä¼˜åŒ–åŠ¨ç”»æ€§èƒ½ */
.smooth-animation {
  /* ä½¿ç”¨transformå’Œopacityè¿›è¡ŒåŠ¨ç”» */
  transform: translateZ(0); /* å¯ç”¨ç¡¬ä»¶åŠ é€Ÿ */
  will-change: transform, opacity;
}

/* ç§»åŠ¨ç«¯ä¼˜åŒ– */
@media (max-width: 768px) {
  .mobile-optimized {
    /* å‡å°‘ç§»åŠ¨ç«¯çš„è§†è§‰æ•ˆæœ */
    animation: none;
    transition: none;
  }
  
  /* è§¦æ‘¸ä¼˜åŒ– */
  .touch-target {
    min-height: 44px;
    min-width: 44px;
  }
}

/* å‡å°‘é‡ç»˜å’Œå›æµ */
.layout-optimized {
  position: relative;
  transform: translateZ(0);
  backface-visibility: hidden;
}
```

### ğŸ“± 2. PWAä¼˜åŒ–é…ç½®
```typescript
// public/sw.js - Service Worker
const CACHE_NAME = 'jinbao-v1.0.0';
const STATIC_CACHE = 'static-v1.0.0';
const DYNAMIC_CACHE = 'dynamic-v1.0.0';

const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/assets/css/main.css',
  '/assets/js/main.js',
  '/manifest.json'
];

// å®‰è£…äº‹ä»¶
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then(cache => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  );
});

// æ¿€æ´»äº‹ä»¶
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => self.clients.claim())
  );
});

// ç½‘ç»œè¯·æ±‚æ‹¦æˆª
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // é™æ€èµ„æºç¼“å­˜ç­–ç•¥
  if (STATIC_ASSETS.includes(url.pathname)) {
    event.respondWith(
      caches.match(request)
        .then(response => response || fetch(request))
    );
    return;
  }
  
  // APIè¯·æ±‚ç¼“å­˜ç­–ç•¥
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(
      caches.open(DYNAMIC_CACHE)
        .then(cache => {
          return fetch(request)
            .then(response => {
              // åªç¼“å­˜æˆåŠŸçš„GETè¯·æ±‚
              if (request.method === 'GET' && response.status === 200) {
                cache.put(request, response.clone());
              }
              return response;
            })
            .catch(() => caches.match(request));
        })
    );
    return;
  }
  
  // é»˜è®¤ç½‘ç»œä¼˜å…ˆç­–ç•¥
  event.respondWith(
    fetch(request)
      .catch(() => caches.match(request))
  );
});
```

---

## ğŸ“Š æ€§èƒ½ç›‘æ§ä¸åˆ†æ

### ğŸ“ˆ 1. æ€§èƒ½ç›‘æ§ç»„ä»¶
```typescript
// src/components/PerformanceMonitor.tsx
import React, { useEffect } from 'react';

interface PerformanceMetrics {
  fcp: number; // First Contentful Paint
  lcp: number; // Largest Contentful Paint
  fid: number; // First Input Delay
  cls: number; // Cumulative Layout Shift
  ttfb: number; // Time to First Byte
}

export const PerformanceMonitor: React.FC = () => {
  useEffect(() => {
    // æ€§èƒ½æŒ‡æ ‡æ”¶é›†
    const collectMetrics = () => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      const paint = performance.getEntriesByType('paint');
      
      const metrics: Partial<PerformanceMetrics> = {
        ttfb: navigation.responseStart - navigation.requestStart,
      };
      
      // FCP
      const fcp = paint.find(entry => entry.name === 'first-contentful-paint');
      if (fcp) metrics.fcp = fcp.startTime;
      
      // LCP
      new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        metrics.lcp = lastEntry.startTime;
      }).observe({ entryTypes: ['largest-contentful-paint'] });
      
      // FID
      new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          metrics.fid = entry.processingStart - entry.startTime;
        });
      }).observe({ entryTypes: ['first-input'] });
      
      // CLS
      let clsValue = 0;
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
          }
        }
        metrics.cls = clsValue;
      }).observe({ entryTypes: ['layout-shift'] });
      
      // å‘é€æŒ‡æ ‡åˆ°åˆ†ææœåŠ¡
      setTimeout(() => {
        sendMetrics(metrics as PerformanceMetrics);
      }, 5000);
    };
    
    // é¡µé¢åŠ è½½å®Œæˆåæ”¶é›†æŒ‡æ ‡
    if (document.readyState === 'complete') {
      collectMetrics();
    } else {
      window.addEventListener('load', collectMetrics);
    }
    
    return () => {
      window.removeEventListener('load', collectMetrics);
    };
  }, []);
  
  return null;
};

async function sendMetrics(metrics: PerformanceMetrics) {
  try {
    await fetch('/api/analytics/performance', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...metrics,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href
      })
    });
  } catch (error) {
    console.warn('Failed to send performance metrics:', error);
  }
}
```

### ğŸ“Š 2. å®æ—¶æ€§èƒ½ä»ªè¡¨æ¿
```typescript
// src/components/PerformanceDashboard.tsx
import React, { useState, useEffect } from 'react';

interface PerformanceData {
  pageLoadTime: number;
  apiResponseTime: number;
  errorRate: number;
  activeUsers: number;
}

export const PerformanceDashboard: React.FC = () => {
  const [perfData, setPerfData] = useState<PerformanceData | null>(null);
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    // åªåœ¨å¼€å‘ç¯å¢ƒæ˜¾ç¤º
    if (process.env.NODE_ENV === 'development') {
      setIsVisible(true);
      
      const fetchPerfData = async () => {
        try {
          const response = await fetch('/api/performance/stats');
          const data = await response.json();
          setPerfData(data);
        } catch (error) {
          console.warn('Failed to fetch performance data:', error);
        }
      };
      
      fetchPerfData();
      const interval = setInterval(fetchPerfData, 10000); // æ¯10ç§’æ›´æ–°
      
      return () => clearInterval(interval);
    }
  }, []);
  
  if (!isVisible || !perfData) return null;
  
  return (
    <div className="fixed bottom-4 right-4 bg-black bg-opacity-80 text-white p-4 rounded-lg text-sm z-50">
      <h3 className="font-bold mb-2">æ€§èƒ½ç›‘æ§</h3>
      <div className="space-y-1">
        <div>é¡µé¢åŠ è½½: {perfData.pageLoadTime}ms</div>
        <div>APIå“åº”: {perfData.apiResponseTime}ms</div>
        <div>é”™è¯¯ç‡: {(perfData.errorRate * 100).toFixed(2)}%</div>
        <div>åœ¨çº¿ç”¨æˆ·: {perfData.activeUsers}</div>
      </div>
    </div>
  );
};
```

---

## ğŸ¯ å®æ–½ä¼˜å…ˆçº§å»ºè®®

### ğŸ”´ é«˜ä¼˜å…ˆçº§ (ç«‹å³å®æ–½)
1. **Viteæ„å»ºä¼˜åŒ–** - ä»£ç åˆ†å‰²å’Œå‹ç¼©
2. **Cloudflareç¼“å­˜é…ç½®** - é™æ€èµ„æºç¼“å­˜
3. **å›¾ç‰‡æ‡’åŠ è½½** - å‡å°‘åˆå§‹åŠ è½½æ—¶é—´
4. **å…³é”®CSSå†…è”** - æå‡é¦–å±æ¸²æŸ“é€Ÿåº¦

### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§ (1-2å‘¨å†…)
1. **Service Workerç¼“å­˜** - ç¦»çº¿æ”¯æŒå’Œç¼“å­˜ç­–ç•¥
2. **Web3è°ƒç”¨ä¼˜åŒ–** - å‡å°‘åŒºå—é“¾æŸ¥è¯¢æ¬¡æ•°
3. **è™šæ‹Ÿæ»šåŠ¨** - å¤§æ•°æ®åˆ—è¡¨æ€§èƒ½ä¼˜åŒ–
4. **æ€§èƒ½ç›‘æ§** - å»ºç«‹æ€§èƒ½åŸºçº¿

### ğŸŸ¢ ä½ä¼˜å…ˆçº§ (1ä¸ªæœˆå†…)
1. **PWAåŠŸèƒ½å®Œå–„** - åº”ç”¨å®‰è£…å’Œæ¨é€é€šçŸ¥
2. **é«˜çº§ç¼“å­˜ç­–ç•¥** - æ™ºèƒ½é¢„åŠ è½½å’Œç¼“å­˜å¤±æ•ˆ
3. **æ€§èƒ½åˆ†æå·¥å…·** - è¯¦ç»†çš„ç”¨æˆ·ä½“éªŒåˆ†æ
4. **A/Bæµ‹è¯•æ¡†æ¶** - æ€§èƒ½ä¼˜åŒ–æ•ˆæœéªŒè¯

---

## ğŸ“ˆ é¢„æœŸæ€§èƒ½æå‡

### ğŸš€ ä¼˜åŒ–å‰åå¯¹æ¯”
| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡å¹…åº¦ |
|------|--------|--------|----------|
| **é¦–å±åŠ è½½æ—¶é—´** | 3-5ç§’ | 1-2ç§’ | 60-70% |
| **é¡µé¢å¤§å°** | 2-3MB | 800KB-1.2MB | 50-60% |
| **APIå“åº”æ—¶é—´** | 500-1000ms | 100-300ms | 70-80% |
| **ç§»åŠ¨ç«¯æ€§èƒ½** | è¾ƒæ…¢ | æµç•… | æ˜¾è‘—æå‡ |
| **ç¼“å­˜å‘½ä¸­ç‡** | 30-40% | 80-90% | 100%+ |

### ğŸ’° æˆæœ¬æ•ˆç›Šåˆ†æ
- **å¼€å‘æˆæœ¬**: 2-3å‘¨å¼€å‘æ—¶é—´
- **ç»´æŠ¤æˆæœ¬**: æ¯æœˆ1-2å¤©ç»´æŠ¤
- **æ”¶ç›Š**: ç”¨æˆ·ä½“éªŒæå‡30%+ï¼Œè½¬åŒ–ç‡æå‡15%+
- **ROI**: é¢„è®¡3-6ä¸ªæœˆå›æ”¶æˆæœ¬

---

**ğŸ“… æ–¹æ¡ˆåˆ¶å®šæ—¥æœŸ**: 2025å¹´12æœˆ30æ—¥  
**ğŸ¯ ç›®æ ‡**: å…¨é¢æå‡ç½‘é¡µæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ  
**ğŸ“Š é¢„æœŸæ•ˆæœ**: é¦–å±åŠ è½½æ—¶é—´å‡å°‘60%ï¼Œæ•´ä½“æ€§èƒ½æå‡50%+  
**ğŸ”„ å®æ–½å‘¨æœŸ**: åˆ†é˜¶æ®µå®æ–½ï¼Œ4-6å‘¨å®Œæˆæ ¸å¿ƒä¼˜åŒ–